/*
 * Telnyx API
 * SIP trunking, SMS, MMS, Call Control and Telephony Data Services.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@telnyx.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.telnyx.sdk.api;

import com.telnyx.sdk.*;
import com.telnyx.sdk.auth.*;
import com.telnyx.sdk.model.CreateVirtualCrossConnect200Response;
import com.telnyx.sdk.model.Errors;
import com.telnyx.sdk.model.ListVirtualCrossConnectCoverage200Response;
import com.telnyx.sdk.model.ListVirtualCrossConnects200Response;
import java.util.UUID;
import com.telnyx.sdk.model.VirtualCrossConnectCreate;
import com.telnyx.sdk.model.VirtualCrossConnectPatch;
import org.junit.Assert;
import org.junit.Ignore;
import org.junit.Test;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for VirtualCrossConnectsApi
 */
public class VirtualCrossConnectsApiTest {

    private final VirtualCrossConnectsApi api = new VirtualCrossConnectsApi();

    /**
     * Create a Virtual Cross Connect
     *
     * Create a new Virtual Cross Connect.&lt;br /&gt;&lt;br /&gt;For AWS and GCE, you have the option of creating the primary connection first and the secondary connection later. You also have the option of disabling the primary and/or secondary connections at any time and later re-enabling them. With Azure, you do not have this option. Azure requires both the primary and secondary connections to be created at the same time and they can not be independantly disabled.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void createVirtualCrossConnectTest() throws ApiException {
        //VirtualCrossConnectCreate virtualCrossConnectCreate = null;
        //CreateVirtualCrossConnect200Response response = api.createVirtualCrossConnect(virtualCrossConnectCreate);
        // TODO: test validations
    }

    /**
     * Delete a Virtual Cross Connect
     *
     * Delete a Virtual Cross Connect.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void deleteVirtualCrossConnectTest() throws ApiException {
        //UUID id = null;
        //CreateVirtualCrossConnect200Response response = api.deleteVirtualCrossConnect(id);
        // TODO: test validations
    }

    /**
     * Retrieve a Virtual Cross Connect
     *
     * Retrieve a Virtual Cross Connect.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getVirtualCrossConnectTest() throws ApiException {
        //UUID id = null;
        //CreateVirtualCrossConnect200Response response = api.getVirtualCrossConnect(id);
        // TODO: test validations
    }

    /**
     * List Virtual Cross Connect Cloud Coverage
     *
     * List Virtual Cross Connects Cloud Coverage.&lt;br /&gt;&lt;br /&gt;This endpoint shows which cloud regions are available for the &#x60;location_code&#x60; your Virtual Cross Connect will be provisioned in.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void listVirtualCrossConnectCoverageTest() throws ApiException {
        //Integer pageNumber = null;
        //Integer pageSize = null;
        //Integer filtersAvailableBandwidthContains = null;
        //String filterCloudProvider = null;
        //String filterCloudProviderRegion = null;
        //String filterLocationRegion = null;
        //String filterLocationSite = null;
        //String filterLocationPop = null;
        //String filterLocationCode = null;
        //ListVirtualCrossConnectCoverage200Response response = api.listVirtualCrossConnectCoverage(pageNumber, pageSize, filtersAvailableBandwidthContains, filterCloudProvider, filterCloudProviderRegion, filterLocationRegion, filterLocationSite, filterLocationPop, filterLocationCode);
        // TODO: test validations
    }

    /**
     * List all Virtual Cross Connects
     *
     * List all Virtual Cross Connects.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void listVirtualCrossConnectsTest() throws ApiException {
        //Integer pageNumber = null;
        //Integer pageSize = null;
        //String filterNetworkId = null;
        //ListVirtualCrossConnects200Response response = api.listVirtualCrossConnects(pageNumber, pageSize, filterNetworkId);
        // TODO: test validations
    }

    /**
     * Update the Virtual Cross Connect
     *
     * Update the Virtual Cross Connect.&lt;br /&gt;&lt;br /&gt;Cloud IPs can only be patched during the &#x60;created&#x60; state, as GCE will only inform you of your generated IP once the pending connection requested has been accepted. Once the Virtual Cross Connect has moved to &#x60;provisioning&#x60;, the IPs can no longer be patched.&lt;br /&gt;&lt;br /&gt;Once the Virtual Cross Connect has moved to &#x60;provisioned&#x60; and you are ready to enable routing, you can toggle the routing announcements to &#x60;true&#x60;.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void updateVirtualCrossConnectTest() throws ApiException {
        //UUID id = null;
        //VirtualCrossConnectPatch virtualCrossConnectPatch = null;
        //CreateVirtualCrossConnect200Response response = api.updateVirtualCrossConnect(id, virtualCrossConnectPatch);
        // TODO: test validations
    }

}
