/*
 * Telnyx API
 * SIP trunking, SMS, MMS, Call Control and Telephony Data Services.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@telnyx.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.telnyx.sdk.model;

import java.util.Objects;
import java.util.Arrays;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.telnyx.sdk.model.CallRequestAnsweringMachineDetectionConfig;
import com.telnyx.sdk.model.CallRequestConferenceConfig;
import com.telnyx.sdk.model.CallRequestTo;
import com.telnyx.sdk.model.CustomSipHeader;
import com.telnyx.sdk.model.DialogflowConfig;
import com.telnyx.sdk.model.SipHeader;
import com.telnyx.sdk.model.SoundModifications;
import com.telnyx.sdk.model.StreamBidirectionalCodec;
import com.telnyx.sdk.model.StreamBidirectionalMode;
import com.telnyx.sdk.model.StreamBidirectionalSamplingRate;
import com.telnyx.sdk.model.StreamBidirectionalTargetLegs;
import com.telnyx.sdk.model.TranscriptionStartRequest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.telnyx.sdk.JSON;


/**
 * CallRequest
 */
@JsonPropertyOrder({
  CallRequest.JSON_PROPERTY_TO,
  CallRequest.JSON_PROPERTY_FROM,
  CallRequest.JSON_PROPERTY_FROM_DISPLAY_NAME,
  CallRequest.JSON_PROPERTY_CONNECTION_ID,
  CallRequest.JSON_PROPERTY_AUDIO_URL,
  CallRequest.JSON_PROPERTY_MEDIA_NAME,
  CallRequest.JSON_PROPERTY_PREFERRED_CODECS,
  CallRequest.JSON_PROPERTY_TIMEOUT_SECS,
  CallRequest.JSON_PROPERTY_TIME_LIMIT_SECS,
  CallRequest.JSON_PROPERTY_ANSWERING_MACHINE_DETECTION,
  CallRequest.JSON_PROPERTY_ANSWERING_MACHINE_DETECTION_CONFIG,
  CallRequest.JSON_PROPERTY_CONFERENCE_CONFIG,
  CallRequest.JSON_PROPERTY_CUSTOM_HEADERS,
  CallRequest.JSON_PROPERTY_BILLING_GROUP_ID,
  CallRequest.JSON_PROPERTY_CLIENT_STATE,
  CallRequest.JSON_PROPERTY_COMMAND_ID,
  CallRequest.JSON_PROPERTY_LINK_TO,
  CallRequest.JSON_PROPERTY_MEDIA_ENCRYPTION,
  CallRequest.JSON_PROPERTY_SIP_AUTH_USERNAME,
  CallRequest.JSON_PROPERTY_SIP_AUTH_PASSWORD,
  CallRequest.JSON_PROPERTY_SIP_HEADERS,
  CallRequest.JSON_PROPERTY_SIP_TRANSPORT_PROTOCOL,
  CallRequest.JSON_PROPERTY_SOUND_MODIFICATIONS,
  CallRequest.JSON_PROPERTY_STREAM_URL,
  CallRequest.JSON_PROPERTY_STREAM_TRACK,
  CallRequest.JSON_PROPERTY_STREAM_BIDIRECTIONAL_MODE,
  CallRequest.JSON_PROPERTY_STREAM_BIDIRECTIONAL_CODEC,
  CallRequest.JSON_PROPERTY_STREAM_BIDIRECTIONAL_TARGET_LEGS,
  CallRequest.JSON_PROPERTY_STREAM_BIDIRECTIONAL_SAMPLING_RATE,
  CallRequest.JSON_PROPERTY_SEND_SILENCE_WHEN_IDLE,
  CallRequest.JSON_PROPERTY_WEBHOOK_URL,
  CallRequest.JSON_PROPERTY_WEBHOOK_URL_METHOD,
  CallRequest.JSON_PROPERTY_RECORD,
  CallRequest.JSON_PROPERTY_RECORD_CHANNELS,
  CallRequest.JSON_PROPERTY_RECORD_FORMAT,
  CallRequest.JSON_PROPERTY_RECORD_MAX_LENGTH,
  CallRequest.JSON_PROPERTY_RECORD_TIMEOUT_SECS,
  CallRequest.JSON_PROPERTY_RECORD_TRACK,
  CallRequest.JSON_PROPERTY_RECORD_TRIM,
  CallRequest.JSON_PROPERTY_RECORD_CUSTOM_FILE_NAME,
  CallRequest.JSON_PROPERTY_SUPERVISE_CALL_CONTROL_ID,
  CallRequest.JSON_PROPERTY_SUPERVISOR_ROLE,
  CallRequest.JSON_PROPERTY_ENABLE_DIALOGFLOW,
  CallRequest.JSON_PROPERTY_DIALOGFLOW_CONFIG,
  CallRequest.JSON_PROPERTY_TRANSCRIPTION,
  CallRequest.JSON_PROPERTY_TRANSCRIPTION_CONFIG
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.11.0")
public class CallRequest {
  public static final String JSON_PROPERTY_TO = "to";
  private CallRequestTo to;

  public static final String JSON_PROPERTY_FROM = "from";
  private String from;

  public static final String JSON_PROPERTY_FROM_DISPLAY_NAME = "from_display_name";
  private String fromDisplayName;

  public static final String JSON_PROPERTY_CONNECTION_ID = "connection_id";
  private String connectionId;

  public static final String JSON_PROPERTY_AUDIO_URL = "audio_url";
  private String audioUrl;

  public static final String JSON_PROPERTY_MEDIA_NAME = "media_name";
  private String mediaName;

  public static final String JSON_PROPERTY_PREFERRED_CODECS = "preferred_codecs";
  private String preferredCodecs;

  public static final String JSON_PROPERTY_TIMEOUT_SECS = "timeout_secs";
  private Integer timeoutSecs = 30;

  public static final String JSON_PROPERTY_TIME_LIMIT_SECS = "time_limit_secs";
  private Integer timeLimitSecs = 14400;

  /**
   * Enables Answering Machine Detection. Telnyx offers Premium and Standard detections. With Premium detection, when a call is answered, Telnyx runs real-time detection and sends a &#x60;call.machine.premium.detection.ended&#x60; webhook with one of the following results: &#x60;human_residence&#x60;, &#x60;human_business&#x60;, &#x60;machine&#x60;, &#x60;silence&#x60; or &#x60;fax_detected&#x60;. If we detect a beep, we also send a &#x60;call.machine.premium.greeting.ended&#x60; webhook with the result of &#x60;beep_detected&#x60;. If we detect a beep before &#x60;call.machine.premium.detection.ended&#x60; we only send &#x60;call.machine.premium.greeting.ended&#x60;, and if we detect a beep after &#x60;call.machine.premium.detection.ended&#x60;, we send both webhooks. With Standard detection, when a call is answered, Telnyx runs real-time detection to determine if it was picked up by a human or a machine and sends an &#x60;call.machine.detection.ended&#x60; webhook with the analysis result. If &#x60;greeting_end&#x60; or &#x60;detect_words&#x60; is used and a &#x60;machine&#x60; is detected, you will receive another &#x60;call.machine.greeting.ended&#x60; webhook when the answering machine greeting ends with a beep or silence. If &#x60;detect_beep&#x60; is used, you will only receive &#x60;call.machine.greeting.ended&#x60; if a beep is detected.
   */
  public enum AnsweringMachineDetectionEnum {
    PREMIUM(String.valueOf("premium")),
    
    DETECT(String.valueOf("detect")),
    
    DETECT_BEEP(String.valueOf("detect_beep")),
    
    DETECT_WORDS(String.valueOf("detect_words")),
    
    GREETING_END(String.valueOf("greeting_end")),
    
    DISABLED(String.valueOf("disabled"));

    private String value;

    AnsweringMachineDetectionEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static AnsweringMachineDetectionEnum fromValue(String value) {
      for (AnsweringMachineDetectionEnum b : AnsweringMachineDetectionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_ANSWERING_MACHINE_DETECTION = "answering_machine_detection";
  private AnsweringMachineDetectionEnum answeringMachineDetection = AnsweringMachineDetectionEnum.DISABLED;

  public static final String JSON_PROPERTY_ANSWERING_MACHINE_DETECTION_CONFIG = "answering_machine_detection_config";
  private CallRequestAnsweringMachineDetectionConfig answeringMachineDetectionConfig;

  public static final String JSON_PROPERTY_CONFERENCE_CONFIG = "conference_config";
  private CallRequestConferenceConfig conferenceConfig;

  public static final String JSON_PROPERTY_CUSTOM_HEADERS = "custom_headers";
  private List<CustomSipHeader> customHeaders = null;

  public static final String JSON_PROPERTY_BILLING_GROUP_ID = "billing_group_id";
  private UUID billingGroupId;

  public static final String JSON_PROPERTY_CLIENT_STATE = "client_state";
  private String clientState;

  public static final String JSON_PROPERTY_COMMAND_ID = "command_id";
  private String commandId;

  public static final String JSON_PROPERTY_LINK_TO = "link_to";
  private String linkTo;

  /**
   * Defines whether media should be encrypted on the call.
   */
  public enum MediaEncryptionEnum {
    DISABLED(String.valueOf("disabled")),
    
    SRTP(String.valueOf("SRTP"));

    private String value;

    MediaEncryptionEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static MediaEncryptionEnum fromValue(String value) {
      for (MediaEncryptionEnum b : MediaEncryptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_MEDIA_ENCRYPTION = "media_encryption";
  private MediaEncryptionEnum mediaEncryption = MediaEncryptionEnum.DISABLED;

  public static final String JSON_PROPERTY_SIP_AUTH_USERNAME = "sip_auth_username";
  private String sipAuthUsername;

  public static final String JSON_PROPERTY_SIP_AUTH_PASSWORD = "sip_auth_password";
  private String sipAuthPassword;

  public static final String JSON_PROPERTY_SIP_HEADERS = "sip_headers";
  private List<SipHeader> sipHeaders = null;

  /**
   * Defines SIP transport protocol to be used on the call.
   */
  public enum SipTransportProtocolEnum {
    UDP(String.valueOf("UDP")),
    
    TCP(String.valueOf("TCP")),
    
    TLS(String.valueOf("TLS"));

    private String value;

    SipTransportProtocolEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static SipTransportProtocolEnum fromValue(String value) {
      for (SipTransportProtocolEnum b : SipTransportProtocolEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_SIP_TRANSPORT_PROTOCOL = "sip_transport_protocol";
  private SipTransportProtocolEnum sipTransportProtocol = SipTransportProtocolEnum.UDP;

  public static final String JSON_PROPERTY_SOUND_MODIFICATIONS = "sound_modifications";
  private SoundModifications soundModifications;

  public static final String JSON_PROPERTY_STREAM_URL = "stream_url";
  private String streamUrl;

  /**
   * Specifies which track should be streamed.
   */
  public enum StreamTrackEnum {
    INBOUND_TRACK(String.valueOf("inbound_track")),
    
    OUTBOUND_TRACK(String.valueOf("outbound_track")),
    
    BOTH_TRACKS(String.valueOf("both_tracks"));

    private String value;

    StreamTrackEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static StreamTrackEnum fromValue(String value) {
      for (StreamTrackEnum b : StreamTrackEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_STREAM_TRACK = "stream_track";
  private StreamTrackEnum streamTrack = StreamTrackEnum.INBOUND_TRACK;

  public static final String JSON_PROPERTY_STREAM_BIDIRECTIONAL_MODE = "stream_bidirectional_mode";
  private StreamBidirectionalMode streamBidirectionalMode = StreamBidirectionalMode.MP3;

  public static final String JSON_PROPERTY_STREAM_BIDIRECTIONAL_CODEC = "stream_bidirectional_codec";
  private StreamBidirectionalCodec streamBidirectionalCodec = StreamBidirectionalCodec.PCMU;

  public static final String JSON_PROPERTY_STREAM_BIDIRECTIONAL_TARGET_LEGS = "stream_bidirectional_target_legs";
  private StreamBidirectionalTargetLegs streamBidirectionalTargetLegs = StreamBidirectionalTargetLegs.OPPOSITE;

  public static final String JSON_PROPERTY_STREAM_BIDIRECTIONAL_SAMPLING_RATE = "stream_bidirectional_sampling_rate";
  private StreamBidirectionalSamplingRate streamBidirectionalSamplingRate = StreamBidirectionalSamplingRate.NUMBER_8000;

  public static final String JSON_PROPERTY_SEND_SILENCE_WHEN_IDLE = "send_silence_when_idle";
  private Boolean sendSilenceWhenIdle = false;

  public static final String JSON_PROPERTY_WEBHOOK_URL = "webhook_url";
  private String webhookUrl;

  /**
   * HTTP request type used for &#x60;webhook_url&#x60;.
   */
  public enum WebhookUrlMethodEnum {
    POST(String.valueOf("POST")),
    
    GET(String.valueOf("GET"));

    private String value;

    WebhookUrlMethodEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static WebhookUrlMethodEnum fromValue(String value) {
      for (WebhookUrlMethodEnum b : WebhookUrlMethodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_WEBHOOK_URL_METHOD = "webhook_url_method";
  private WebhookUrlMethodEnum webhookUrlMethod = WebhookUrlMethodEnum.POST;

  /**
   * Start recording automatically after an event. Disabled by default.
   */
  public enum RecordEnum {
    RECORD_FROM_ANSWER(String.valueOf("record-from-answer"));

    private String value;

    RecordEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static RecordEnum fromValue(String value) {
      for (RecordEnum b : RecordEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_RECORD = "record";
  private RecordEnum record;

  /**
   * Defines which channel should be recorded (&#39;single&#39; or &#39;dual&#39;) when &#x60;record&#x60; is specified.
   */
  public enum RecordChannelsEnum {
    SINGLE(String.valueOf("single")),
    
    DUAL(String.valueOf("dual"));

    private String value;

    RecordChannelsEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static RecordChannelsEnum fromValue(String value) {
      for (RecordChannelsEnum b : RecordChannelsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_RECORD_CHANNELS = "record_channels";
  private RecordChannelsEnum recordChannels = RecordChannelsEnum.DUAL;

  /**
   * Defines the format of the recording (&#39;wav&#39; or &#39;mp3&#39;) when &#x60;record&#x60; is specified.
   */
  public enum RecordFormatEnum {
    WAV(String.valueOf("wav")),
    
    MP3(String.valueOf("mp3"));

    private String value;

    RecordFormatEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static RecordFormatEnum fromValue(String value) {
      for (RecordFormatEnum b : RecordFormatEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_RECORD_FORMAT = "record_format";
  private RecordFormatEnum recordFormat = RecordFormatEnum.MP3;

  public static final String JSON_PROPERTY_RECORD_MAX_LENGTH = "record_max_length";
  private Integer recordMaxLength = 0;

  public static final String JSON_PROPERTY_RECORD_TIMEOUT_SECS = "record_timeout_secs";
  private Integer recordTimeoutSecs = 0;

  /**
   * The audio track to be recorded. Can be either &#x60;both&#x60;, &#x60;inbound&#x60; or &#x60;outbound&#x60;. If only single track is specified (&#x60;inbound&#x60;, &#x60;outbound&#x60;), &#x60;channels&#x60; configuration is ignored and it will be recorded as mono (single channel).
   */
  public enum RecordTrackEnum {
    BOTH(String.valueOf("both")),
    
    INBOUND(String.valueOf("inbound")),
    
    OUTBOUND(String.valueOf("outbound"));

    private String value;

    RecordTrackEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static RecordTrackEnum fromValue(String value) {
      for (RecordTrackEnum b : RecordTrackEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_RECORD_TRACK = "record_track";
  private RecordTrackEnum recordTrack = RecordTrackEnum.BOTH;

  /**
   * When set to &#x60;trim-silence&#x60;, silence will be removed from the beginning and end of the recording.
   */
  public enum RecordTrimEnum {
    TRIM_SILENCE(String.valueOf("trim-silence"));

    private String value;

    RecordTrimEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static RecordTrimEnum fromValue(String value) {
      for (RecordTrimEnum b : RecordTrimEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_RECORD_TRIM = "record_trim";
  private RecordTrimEnum recordTrim;

  public static final String JSON_PROPERTY_RECORD_CUSTOM_FILE_NAME = "record_custom_file_name";
  private String recordCustomFileName;

  public static final String JSON_PROPERTY_SUPERVISE_CALL_CONTROL_ID = "supervise_call_control_id";
  private String superviseCallControlId;

  /**
   * The role of the supervisor call. &#39;barge&#39; means that supervisor call hears and is being heard by both ends of the call (caller &amp; callee). &#39;whisper&#39; means that only supervised_call_control_id hears supervisor but supervisor can hear everything. &#39;monitor&#39; means that nobody can hear supervisor call, but supervisor can hear everything on the call.
   */
  public enum SupervisorRoleEnum {
    BARGE(String.valueOf("barge")),
    
    WHISPER(String.valueOf("whisper")),
    
    MONITOR(String.valueOf("monitor"));

    private String value;

    SupervisorRoleEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static SupervisorRoleEnum fromValue(String value) {
      for (SupervisorRoleEnum b : SupervisorRoleEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_SUPERVISOR_ROLE = "supervisor_role";
  private SupervisorRoleEnum supervisorRole = SupervisorRoleEnum.BARGE;

  public static final String JSON_PROPERTY_ENABLE_DIALOGFLOW = "enable_dialogflow";
  private Boolean enableDialogflow = false;

  public static final String JSON_PROPERTY_DIALOGFLOW_CONFIG = "dialogflow_config";
  private DialogflowConfig dialogflowConfig;

  public static final String JSON_PROPERTY_TRANSCRIPTION = "transcription";
  private Boolean transcription = false;

  public static final String JSON_PROPERTY_TRANSCRIPTION_CONFIG = "transcription_config";
  private TranscriptionStartRequest transcriptionConfig;

  public CallRequest() { 
  }

  public CallRequest to(CallRequestTo to) {
    this.to = to;
    return this;
  }

   /**
   * Get to
   * @return to
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(JSON_PROPERTY_TO)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public CallRequestTo getTo() {
    return to;
  }


  @JsonProperty(JSON_PROPERTY_TO)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setTo(CallRequestTo to) {
    this.to = to;
  }


  public CallRequest from(String from) {
    this.from = from;
    return this;
  }

   /**
   * The &#x60;from&#x60; number to be used as the caller id presented to the destination (&#x60;to&#x60; number). The number should be in +E164 format.
   * @return from
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(example = "+18005550101", required = true, value = "The `from` number to be used as the caller id presented to the destination (`to` number). The number should be in +E164 format.")
  @JsonProperty(JSON_PROPERTY_FROM)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getFrom() {
    return from;
  }


  @JsonProperty(JSON_PROPERTY_FROM)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setFrom(String from) {
    this.from = from;
  }


  public CallRequest fromDisplayName(String fromDisplayName) {
    this.fromDisplayName = fromDisplayName;
    return this;
  }

   /**
   * The &#x60;from_display_name&#x60; string to be used as the caller id name (SIP From Display Name) presented to the destination (&#x60;to&#x60; number). The string should have a maximum of 128 characters, containing only letters, numbers, spaces, and -_~!.+ special characters. If ommited, the display name will be the same as the number in the &#x60;from&#x60; field.
   * @return fromDisplayName
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "Company Name", value = "The `from_display_name` string to be used as the caller id name (SIP From Display Name) presented to the destination (`to` number). The string should have a maximum of 128 characters, containing only letters, numbers, spaces, and -_~!.+ special characters. If ommited, the display name will be the same as the number in the `from` field.")
  @JsonProperty(JSON_PROPERTY_FROM_DISPLAY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getFromDisplayName() {
    return fromDisplayName;
  }


  @JsonProperty(JSON_PROPERTY_FROM_DISPLAY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFromDisplayName(String fromDisplayName) {
    this.fromDisplayName = fromDisplayName;
  }


  public CallRequest connectionId(String connectionId) {
    this.connectionId = connectionId;
    return this;
  }

   /**
   * The ID of the Call Control App (formerly ID of the connection) to be used when dialing the destination.
   * @return connectionId
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The ID of the Call Control App (formerly ID of the connection) to be used when dialing the destination.")
  @JsonProperty(JSON_PROPERTY_CONNECTION_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getConnectionId() {
    return connectionId;
  }


  @JsonProperty(JSON_PROPERTY_CONNECTION_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setConnectionId(String connectionId) {
    this.connectionId = connectionId;
  }


  public CallRequest audioUrl(String audioUrl) {
    this.audioUrl = audioUrl;
    return this;
  }

   /**
   * The URL of a file to be played back to the callee when the call is answered. The URL can point to either a WAV or MP3 file. media_name and audio_url cannot be used together in one request.
   * @return audioUrl
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "http://example.com/message.wav", value = "The URL of a file to be played back to the callee when the call is answered. The URL can point to either a WAV or MP3 file. media_name and audio_url cannot be used together in one request.")
  @JsonProperty(JSON_PROPERTY_AUDIO_URL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getAudioUrl() {
    return audioUrl;
  }


  @JsonProperty(JSON_PROPERTY_AUDIO_URL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAudioUrl(String audioUrl) {
    this.audioUrl = audioUrl;
  }


  public CallRequest mediaName(String mediaName) {
    this.mediaName = mediaName;
    return this;
  }

   /**
   * The media_name of a file to be played back to the callee when the call is answered. The media_name must point to a file previously uploaded to api.telnyx.com/v2/media by the same user/organization. The file must either be a WAV or MP3 file.
   * @return mediaName
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "my_media_uploaded_to_media_storage_api", value = "The media_name of a file to be played back to the callee when the call is answered. The media_name must point to a file previously uploaded to api.telnyx.com/v2/media by the same user/organization. The file must either be a WAV or MP3 file.")
  @JsonProperty(JSON_PROPERTY_MEDIA_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getMediaName() {
    return mediaName;
  }


  @JsonProperty(JSON_PROPERTY_MEDIA_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setMediaName(String mediaName) {
    this.mediaName = mediaName;
  }


  public CallRequest preferredCodecs(String preferredCodecs) {
    this.preferredCodecs = preferredCodecs;
    return this;
  }

   /**
   * The list of comma-separated codecs in a preferred order for the forked media to be received.
   * @return preferredCodecs
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "G722,PCMU,PCMA,G729,OPUS,VP8,H264", value = "The list of comma-separated codecs in a preferred order for the forked media to be received.")
  @JsonProperty(JSON_PROPERTY_PREFERRED_CODECS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getPreferredCodecs() {
    return preferredCodecs;
  }


  @JsonProperty(JSON_PROPERTY_PREFERRED_CODECS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPreferredCodecs(String preferredCodecs) {
    this.preferredCodecs = preferredCodecs;
  }


  public CallRequest timeoutSecs(Integer timeoutSecs) {
    this.timeoutSecs = timeoutSecs;
    return this;
  }

   /**
   * The number of seconds that Telnyx will wait for the call to be answered by the destination to which it is being called. If the timeout is reached before an answer is received, the call will hangup and a &#x60;call.hangup&#x60; webhook with a &#x60;hangup_cause&#x60; of &#x60;timeout&#x60; will be sent. Minimum value is 5 seconds. Maximum value is 600 seconds.
   * @return timeoutSecs
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "60", value = "The number of seconds that Telnyx will wait for the call to be answered by the destination to which it is being called. If the timeout is reached before an answer is received, the call will hangup and a `call.hangup` webhook with a `hangup_cause` of `timeout` will be sent. Minimum value is 5 seconds. Maximum value is 600 seconds.")
  @JsonProperty(JSON_PROPERTY_TIMEOUT_SECS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getTimeoutSecs() {
    return timeoutSecs;
  }


  @JsonProperty(JSON_PROPERTY_TIMEOUT_SECS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTimeoutSecs(Integer timeoutSecs) {
    this.timeoutSecs = timeoutSecs;
  }


  public CallRequest timeLimitSecs(Integer timeLimitSecs) {
    this.timeLimitSecs = timeLimitSecs;
    return this;
  }

   /**
   * Sets the maximum duration of a Call Control Leg in seconds. If the time limit is reached, the call will hangup and a &#x60;call.hangup&#x60; webhook with a &#x60;hangup_cause&#x60; of &#x60;time_limit&#x60; will be sent. For example, by setting a time limit of 120 seconds, a Call Leg will be automatically terminated two minutes after being answered. The default time limit is 14400 seconds or 4 hours and this is also the maximum allowed call length.
   * minimum: 30
   * maximum: 14400
   * @return timeLimitSecs
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "600", value = "Sets the maximum duration of a Call Control Leg in seconds. If the time limit is reached, the call will hangup and a `call.hangup` webhook with a `hangup_cause` of `time_limit` will be sent. For example, by setting a time limit of 120 seconds, a Call Leg will be automatically terminated two minutes after being answered. The default time limit is 14400 seconds or 4 hours and this is also the maximum allowed call length.")
  @JsonProperty(JSON_PROPERTY_TIME_LIMIT_SECS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getTimeLimitSecs() {
    return timeLimitSecs;
  }


  @JsonProperty(JSON_PROPERTY_TIME_LIMIT_SECS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTimeLimitSecs(Integer timeLimitSecs) {
    this.timeLimitSecs = timeLimitSecs;
  }


  public CallRequest answeringMachineDetection(AnsweringMachineDetectionEnum answeringMachineDetection) {
    this.answeringMachineDetection = answeringMachineDetection;
    return this;
  }

   /**
   * Enables Answering Machine Detection. Telnyx offers Premium and Standard detections. With Premium detection, when a call is answered, Telnyx runs real-time detection and sends a &#x60;call.machine.premium.detection.ended&#x60; webhook with one of the following results: &#x60;human_residence&#x60;, &#x60;human_business&#x60;, &#x60;machine&#x60;, &#x60;silence&#x60; or &#x60;fax_detected&#x60;. If we detect a beep, we also send a &#x60;call.machine.premium.greeting.ended&#x60; webhook with the result of &#x60;beep_detected&#x60;. If we detect a beep before &#x60;call.machine.premium.detection.ended&#x60; we only send &#x60;call.machine.premium.greeting.ended&#x60;, and if we detect a beep after &#x60;call.machine.premium.detection.ended&#x60;, we send both webhooks. With Standard detection, when a call is answered, Telnyx runs real-time detection to determine if it was picked up by a human or a machine and sends an &#x60;call.machine.detection.ended&#x60; webhook with the analysis result. If &#x60;greeting_end&#x60; or &#x60;detect_words&#x60; is used and a &#x60;machine&#x60; is detected, you will receive another &#x60;call.machine.greeting.ended&#x60; webhook when the answering machine greeting ends with a beep or silence. If &#x60;detect_beep&#x60; is used, you will only receive &#x60;call.machine.greeting.ended&#x60; if a beep is detected.
   * @return answeringMachineDetection
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "Enables Answering Machine Detection. Telnyx offers Premium and Standard detections. With Premium detection, when a call is answered, Telnyx runs real-time detection and sends a `call.machine.premium.detection.ended` webhook with one of the following results: `human_residence`, `human_business`, `machine`, `silence` or `fax_detected`. If we detect a beep, we also send a `call.machine.premium.greeting.ended` webhook with the result of `beep_detected`. If we detect a beep before `call.machine.premium.detection.ended` we only send `call.machine.premium.greeting.ended`, and if we detect a beep after `call.machine.premium.detection.ended`, we send both webhooks. With Standard detection, when a call is answered, Telnyx runs real-time detection to determine if it was picked up by a human or a machine and sends an `call.machine.detection.ended` webhook with the analysis result. If `greeting_end` or `detect_words` is used and a `machine` is detected, you will receive another `call.machine.greeting.ended` webhook when the answering machine greeting ends with a beep or silence. If `detect_beep` is used, you will only receive `call.machine.greeting.ended` if a beep is detected.")
  @JsonProperty(JSON_PROPERTY_ANSWERING_MACHINE_DETECTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public AnsweringMachineDetectionEnum getAnsweringMachineDetection() {
    return answeringMachineDetection;
  }


  @JsonProperty(JSON_PROPERTY_ANSWERING_MACHINE_DETECTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAnsweringMachineDetection(AnsweringMachineDetectionEnum answeringMachineDetection) {
    this.answeringMachineDetection = answeringMachineDetection;
  }


  public CallRequest answeringMachineDetectionConfig(CallRequestAnsweringMachineDetectionConfig answeringMachineDetectionConfig) {
    this.answeringMachineDetectionConfig = answeringMachineDetectionConfig;
    return this;
  }

   /**
   * Get answeringMachineDetectionConfig
   * @return answeringMachineDetectionConfig
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_ANSWERING_MACHINE_DETECTION_CONFIG)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public CallRequestAnsweringMachineDetectionConfig getAnsweringMachineDetectionConfig() {
    return answeringMachineDetectionConfig;
  }


  @JsonProperty(JSON_PROPERTY_ANSWERING_MACHINE_DETECTION_CONFIG)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAnsweringMachineDetectionConfig(CallRequestAnsweringMachineDetectionConfig answeringMachineDetectionConfig) {
    this.answeringMachineDetectionConfig = answeringMachineDetectionConfig;
  }


  public CallRequest conferenceConfig(CallRequestConferenceConfig conferenceConfig) {
    this.conferenceConfig = conferenceConfig;
    return this;
  }

   /**
   * Get conferenceConfig
   * @return conferenceConfig
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_CONFERENCE_CONFIG)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public CallRequestConferenceConfig getConferenceConfig() {
    return conferenceConfig;
  }


  @JsonProperty(JSON_PROPERTY_CONFERENCE_CONFIG)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setConferenceConfig(CallRequestConferenceConfig conferenceConfig) {
    this.conferenceConfig = conferenceConfig;
  }


  public CallRequest customHeaders(List<CustomSipHeader> customHeaders) {
    this.customHeaders = customHeaders;
    return this;
  }

  public CallRequest addcustomHeadersItem(CustomSipHeader customHeadersItem) {
    if (this.customHeaders == null) {
      this.customHeaders = new ArrayList<>();
    }
    this.customHeaders.add(customHeadersItem);
    return this;
  }

   /**
   * Custom headers to be added to the SIP INVITE.
   * @return customHeaders
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "[{\"name\":\"head_1\",\"value\":\"val_1\"},{\"name\":\"head_2\",\"value\":\"val_2\"}]", value = "Custom headers to be added to the SIP INVITE.")
  @JsonProperty(JSON_PROPERTY_CUSTOM_HEADERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<CustomSipHeader> getCustomHeaders() {
    return customHeaders;
  }


  @JsonProperty(JSON_PROPERTY_CUSTOM_HEADERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCustomHeaders(List<CustomSipHeader> customHeaders) {
    this.customHeaders = customHeaders;
  }


  public CallRequest billingGroupId(UUID billingGroupId) {
    this.billingGroupId = billingGroupId;
    return this;
  }

   /**
   * Use this field to set the Billing Group ID for the call. Must be a valid and existing Billing Group ID.
   * @return billingGroupId
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "f5586561-8ff0-4291-a0ac-84fe544797bd", value = "Use this field to set the Billing Group ID for the call. Must be a valid and existing Billing Group ID.")
  @JsonProperty(JSON_PROPERTY_BILLING_GROUP_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public UUID getBillingGroupId() {
    return billingGroupId;
  }


  @JsonProperty(JSON_PROPERTY_BILLING_GROUP_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setBillingGroupId(UUID billingGroupId) {
    this.billingGroupId = billingGroupId;
  }


  public CallRequest clientState(String clientState) {
    this.clientState = clientState;
    return this;
  }

   /**
   * Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
   * @return clientState
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "aGF2ZSBhIG5pY2UgZGF5ID1d", value = "Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.")
  @JsonProperty(JSON_PROPERTY_CLIENT_STATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getClientState() {
    return clientState;
  }


  @JsonProperty(JSON_PROPERTY_CLIENT_STATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setClientState(String clientState) {
    this.clientState = clientState;
  }


  public CallRequest commandId(String commandId) {
    this.commandId = commandId;
    return this;
  }

   /**
   * Use this field to avoid duplicate commands. Telnyx will ignore others Dial commands with the same &#x60;command_id&#x60;.
   * @return commandId
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "891510ac-f3e4-11e8-af5b-de00688a4901", value = "Use this field to avoid duplicate commands. Telnyx will ignore others Dial commands with the same `command_id`.")
  @JsonProperty(JSON_PROPERTY_COMMAND_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getCommandId() {
    return commandId;
  }


  @JsonProperty(JSON_PROPERTY_COMMAND_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCommandId(String commandId) {
    this.commandId = commandId;
  }


  public CallRequest linkTo(String linkTo) {
    this.linkTo = linkTo;
    return this;
  }

   /**
   * Use another call&#39;s control id for sharing the same call session id
   * @return linkTo
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "ilditnZK_eVysupV21KzmzN_sM29ygfauQojpm4BgFtfX5hXAcjotg==", value = "Use another call's control id for sharing the same call session id")
  @JsonProperty(JSON_PROPERTY_LINK_TO)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getLinkTo() {
    return linkTo;
  }


  @JsonProperty(JSON_PROPERTY_LINK_TO)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLinkTo(String linkTo) {
    this.linkTo = linkTo;
  }


  public CallRequest mediaEncryption(MediaEncryptionEnum mediaEncryption) {
    this.mediaEncryption = mediaEncryption;
    return this;
  }

   /**
   * Defines whether media should be encrypted on the call.
   * @return mediaEncryption
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "Defines whether media should be encrypted on the call.")
  @JsonProperty(JSON_PROPERTY_MEDIA_ENCRYPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public MediaEncryptionEnum getMediaEncryption() {
    return mediaEncryption;
  }


  @JsonProperty(JSON_PROPERTY_MEDIA_ENCRYPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setMediaEncryption(MediaEncryptionEnum mediaEncryption) {
    this.mediaEncryption = mediaEncryption;
  }


  public CallRequest sipAuthUsername(String sipAuthUsername) {
    this.sipAuthUsername = sipAuthUsername;
    return this;
  }

   /**
   * SIP Authentication username used for SIP challenges.
   * @return sipAuthUsername
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "SIP Authentication username used for SIP challenges.")
  @JsonProperty(JSON_PROPERTY_SIP_AUTH_USERNAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getSipAuthUsername() {
    return sipAuthUsername;
  }


  @JsonProperty(JSON_PROPERTY_SIP_AUTH_USERNAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSipAuthUsername(String sipAuthUsername) {
    this.sipAuthUsername = sipAuthUsername;
  }


  public CallRequest sipAuthPassword(String sipAuthPassword) {
    this.sipAuthPassword = sipAuthPassword;
    return this;
  }

   /**
   * SIP Authentication password used for SIP challenges.
   * @return sipAuthPassword
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "SIP Authentication password used for SIP challenges.")
  @JsonProperty(JSON_PROPERTY_SIP_AUTH_PASSWORD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getSipAuthPassword() {
    return sipAuthPassword;
  }


  @JsonProperty(JSON_PROPERTY_SIP_AUTH_PASSWORD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSipAuthPassword(String sipAuthPassword) {
    this.sipAuthPassword = sipAuthPassword;
  }


  public CallRequest sipHeaders(List<SipHeader> sipHeaders) {
    this.sipHeaders = sipHeaders;
    return this;
  }

  public CallRequest addsipHeadersItem(SipHeader sipHeadersItem) {
    if (this.sipHeaders == null) {
      this.sipHeaders = new ArrayList<>();
    }
    this.sipHeaders.add(sipHeadersItem);
    return this;
  }

   /**
   * SIP headers to be added to the SIP INVITE request. Currently only User-to-User header is supported.
   * @return sipHeaders
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "[{\"name\":\"User-to-User\",\"value\":\"value\"}]", value = "SIP headers to be added to the SIP INVITE request. Currently only User-to-User header is supported.")
  @JsonProperty(JSON_PROPERTY_SIP_HEADERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<SipHeader> getSipHeaders() {
    return sipHeaders;
  }


  @JsonProperty(JSON_PROPERTY_SIP_HEADERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSipHeaders(List<SipHeader> sipHeaders) {
    this.sipHeaders = sipHeaders;
  }


  public CallRequest sipTransportProtocol(SipTransportProtocolEnum sipTransportProtocol) {
    this.sipTransportProtocol = sipTransportProtocol;
    return this;
  }

   /**
   * Defines SIP transport protocol to be used on the call.
   * @return sipTransportProtocol
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "Defines SIP transport protocol to be used on the call.")
  @JsonProperty(JSON_PROPERTY_SIP_TRANSPORT_PROTOCOL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public SipTransportProtocolEnum getSipTransportProtocol() {
    return sipTransportProtocol;
  }


  @JsonProperty(JSON_PROPERTY_SIP_TRANSPORT_PROTOCOL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSipTransportProtocol(SipTransportProtocolEnum sipTransportProtocol) {
    this.sipTransportProtocol = sipTransportProtocol;
  }


  public CallRequest soundModifications(SoundModifications soundModifications) {
    this.soundModifications = soundModifications;
    return this;
  }

   /**
   * Get soundModifications
   * @return soundModifications
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_SOUND_MODIFICATIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public SoundModifications getSoundModifications() {
    return soundModifications;
  }


  @JsonProperty(JSON_PROPERTY_SOUND_MODIFICATIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSoundModifications(SoundModifications soundModifications) {
    this.soundModifications = soundModifications;
  }


  public CallRequest streamUrl(String streamUrl) {
    this.streamUrl = streamUrl;
    return this;
  }

   /**
   * The destination WebSocket address where the stream is going to be delivered.
   * @return streamUrl
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "wss://www.example.com/websocket", value = "The destination WebSocket address where the stream is going to be delivered.")
  @JsonProperty(JSON_PROPERTY_STREAM_URL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getStreamUrl() {
    return streamUrl;
  }


  @JsonProperty(JSON_PROPERTY_STREAM_URL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStreamUrl(String streamUrl) {
    this.streamUrl = streamUrl;
  }


  public CallRequest streamTrack(StreamTrackEnum streamTrack) {
    this.streamTrack = streamTrack;
    return this;
  }

   /**
   * Specifies which track should be streamed.
   * @return streamTrack
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "both_tracks", value = "Specifies which track should be streamed.")
  @JsonProperty(JSON_PROPERTY_STREAM_TRACK)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public StreamTrackEnum getStreamTrack() {
    return streamTrack;
  }


  @JsonProperty(JSON_PROPERTY_STREAM_TRACK)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStreamTrack(StreamTrackEnum streamTrack) {
    this.streamTrack = streamTrack;
  }


  public CallRequest streamBidirectionalMode(StreamBidirectionalMode streamBidirectionalMode) {
    this.streamBidirectionalMode = streamBidirectionalMode;
    return this;
  }

   /**
   * Get streamBidirectionalMode
   * @return streamBidirectionalMode
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_STREAM_BIDIRECTIONAL_MODE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public StreamBidirectionalMode getStreamBidirectionalMode() {
    return streamBidirectionalMode;
  }


  @JsonProperty(JSON_PROPERTY_STREAM_BIDIRECTIONAL_MODE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStreamBidirectionalMode(StreamBidirectionalMode streamBidirectionalMode) {
    this.streamBidirectionalMode = streamBidirectionalMode;
  }


  public CallRequest streamBidirectionalCodec(StreamBidirectionalCodec streamBidirectionalCodec) {
    this.streamBidirectionalCodec = streamBidirectionalCodec;
    return this;
  }

   /**
   * Get streamBidirectionalCodec
   * @return streamBidirectionalCodec
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_STREAM_BIDIRECTIONAL_CODEC)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public StreamBidirectionalCodec getStreamBidirectionalCodec() {
    return streamBidirectionalCodec;
  }


  @JsonProperty(JSON_PROPERTY_STREAM_BIDIRECTIONAL_CODEC)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStreamBidirectionalCodec(StreamBidirectionalCodec streamBidirectionalCodec) {
    this.streamBidirectionalCodec = streamBidirectionalCodec;
  }


  public CallRequest streamBidirectionalTargetLegs(StreamBidirectionalTargetLegs streamBidirectionalTargetLegs) {
    this.streamBidirectionalTargetLegs = streamBidirectionalTargetLegs;
    return this;
  }

   /**
   * Get streamBidirectionalTargetLegs
   * @return streamBidirectionalTargetLegs
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_STREAM_BIDIRECTIONAL_TARGET_LEGS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public StreamBidirectionalTargetLegs getStreamBidirectionalTargetLegs() {
    return streamBidirectionalTargetLegs;
  }


  @JsonProperty(JSON_PROPERTY_STREAM_BIDIRECTIONAL_TARGET_LEGS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStreamBidirectionalTargetLegs(StreamBidirectionalTargetLegs streamBidirectionalTargetLegs) {
    this.streamBidirectionalTargetLegs = streamBidirectionalTargetLegs;
  }


  public CallRequest streamBidirectionalSamplingRate(StreamBidirectionalSamplingRate streamBidirectionalSamplingRate) {
    this.streamBidirectionalSamplingRate = streamBidirectionalSamplingRate;
    return this;
  }

   /**
   * Get streamBidirectionalSamplingRate
   * @return streamBidirectionalSamplingRate
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_STREAM_BIDIRECTIONAL_SAMPLING_RATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public StreamBidirectionalSamplingRate getStreamBidirectionalSamplingRate() {
    return streamBidirectionalSamplingRate;
  }


  @JsonProperty(JSON_PROPERTY_STREAM_BIDIRECTIONAL_SAMPLING_RATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStreamBidirectionalSamplingRate(StreamBidirectionalSamplingRate streamBidirectionalSamplingRate) {
    this.streamBidirectionalSamplingRate = streamBidirectionalSamplingRate;
  }


  public CallRequest sendSilenceWhenIdle(Boolean sendSilenceWhenIdle) {
    this.sendSilenceWhenIdle = sendSilenceWhenIdle;
    return this;
  }

   /**
   * Generate silence RTP packets when no transmission available.
   * @return sendSilenceWhenIdle
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "true", value = "Generate silence RTP packets when no transmission available.")
  @JsonProperty(JSON_PROPERTY_SEND_SILENCE_WHEN_IDLE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getSendSilenceWhenIdle() {
    return sendSilenceWhenIdle;
  }


  @JsonProperty(JSON_PROPERTY_SEND_SILENCE_WHEN_IDLE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSendSilenceWhenIdle(Boolean sendSilenceWhenIdle) {
    this.sendSilenceWhenIdle = sendSilenceWhenIdle;
  }


  public CallRequest webhookUrl(String webhookUrl) {
    this.webhookUrl = webhookUrl;
    return this;
  }

   /**
   * Use this field to override the URL for which Telnyx will send subsequent webhooks to for this call.
   * @return webhookUrl
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "https://www.example.com/server-b/", value = "Use this field to override the URL for which Telnyx will send subsequent webhooks to for this call.")
  @JsonProperty(JSON_PROPERTY_WEBHOOK_URL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getWebhookUrl() {
    return webhookUrl;
  }


  @JsonProperty(JSON_PROPERTY_WEBHOOK_URL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setWebhookUrl(String webhookUrl) {
    this.webhookUrl = webhookUrl;
  }


  public CallRequest webhookUrlMethod(WebhookUrlMethodEnum webhookUrlMethod) {
    this.webhookUrlMethod = webhookUrlMethod;
    return this;
  }

   /**
   * HTTP request type used for &#x60;webhook_url&#x60;.
   * @return webhookUrlMethod
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "GET", value = "HTTP request type used for `webhook_url`.")
  @JsonProperty(JSON_PROPERTY_WEBHOOK_URL_METHOD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public WebhookUrlMethodEnum getWebhookUrlMethod() {
    return webhookUrlMethod;
  }


  @JsonProperty(JSON_PROPERTY_WEBHOOK_URL_METHOD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setWebhookUrlMethod(WebhookUrlMethodEnum webhookUrlMethod) {
    this.webhookUrlMethod = webhookUrlMethod;
  }


  public CallRequest record(RecordEnum record) {
    this.record = record;
    return this;
  }

   /**
   * Start recording automatically after an event. Disabled by default.
   * @return record
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "record-from-answer", value = "Start recording automatically after an event. Disabled by default.")
  @JsonProperty(JSON_PROPERTY_RECORD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public RecordEnum getRecord() {
    return record;
  }


  @JsonProperty(JSON_PROPERTY_RECORD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRecord(RecordEnum record) {
    this.record = record;
  }


  public CallRequest recordChannels(RecordChannelsEnum recordChannels) {
    this.recordChannels = recordChannels;
    return this;
  }

   /**
   * Defines which channel should be recorded (&#39;single&#39; or &#39;dual&#39;) when &#x60;record&#x60; is specified.
   * @return recordChannels
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "single", value = "Defines which channel should be recorded ('single' or 'dual') when `record` is specified.")
  @JsonProperty(JSON_PROPERTY_RECORD_CHANNELS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public RecordChannelsEnum getRecordChannels() {
    return recordChannels;
  }


  @JsonProperty(JSON_PROPERTY_RECORD_CHANNELS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRecordChannels(RecordChannelsEnum recordChannels) {
    this.recordChannels = recordChannels;
  }


  public CallRequest recordFormat(RecordFormatEnum recordFormat) {
    this.recordFormat = recordFormat;
    return this;
  }

   /**
   * Defines the format of the recording (&#39;wav&#39; or &#39;mp3&#39;) when &#x60;record&#x60; is specified.
   * @return recordFormat
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "wav", value = "Defines the format of the recording ('wav' or 'mp3') when `record` is specified.")
  @JsonProperty(JSON_PROPERTY_RECORD_FORMAT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public RecordFormatEnum getRecordFormat() {
    return recordFormat;
  }


  @JsonProperty(JSON_PROPERTY_RECORD_FORMAT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRecordFormat(RecordFormatEnum recordFormat) {
    this.recordFormat = recordFormat;
  }


  public CallRequest recordMaxLength(Integer recordMaxLength) {
    this.recordMaxLength = recordMaxLength;
    return this;
  }

   /**
   * Defines the maximum length for the recording in seconds when &#x60;record&#x60; is specified. The minimum value is 0. The maximum value is 43200. The default value is 0 (infinite).
   * @return recordMaxLength
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "1000", value = "Defines the maximum length for the recording in seconds when `record` is specified. The minimum value is 0. The maximum value is 43200. The default value is 0 (infinite).")
  @JsonProperty(JSON_PROPERTY_RECORD_MAX_LENGTH)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getRecordMaxLength() {
    return recordMaxLength;
  }


  @JsonProperty(JSON_PROPERTY_RECORD_MAX_LENGTH)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRecordMaxLength(Integer recordMaxLength) {
    this.recordMaxLength = recordMaxLength;
  }


  public CallRequest recordTimeoutSecs(Integer recordTimeoutSecs) {
    this.recordTimeoutSecs = recordTimeoutSecs;
    return this;
  }

   /**
   * The number of seconds that Telnyx will wait for the recording to be stopped if silence is detected when &#x60;record&#x60; is specified. The timer only starts when the speech is detected. Please note that call transcription is used to detect silence and the related charge will be applied. The minimum value is 0. The default value is 0 (infinite).
   * @return recordTimeoutSecs
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "100", value = "The number of seconds that Telnyx will wait for the recording to be stopped if silence is detected when `record` is specified. The timer only starts when the speech is detected. Please note that call transcription is used to detect silence and the related charge will be applied. The minimum value is 0. The default value is 0 (infinite).")
  @JsonProperty(JSON_PROPERTY_RECORD_TIMEOUT_SECS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getRecordTimeoutSecs() {
    return recordTimeoutSecs;
  }


  @JsonProperty(JSON_PROPERTY_RECORD_TIMEOUT_SECS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRecordTimeoutSecs(Integer recordTimeoutSecs) {
    this.recordTimeoutSecs = recordTimeoutSecs;
  }


  public CallRequest recordTrack(RecordTrackEnum recordTrack) {
    this.recordTrack = recordTrack;
    return this;
  }

   /**
   * The audio track to be recorded. Can be either &#x60;both&#x60;, &#x60;inbound&#x60; or &#x60;outbound&#x60;. If only single track is specified (&#x60;inbound&#x60;, &#x60;outbound&#x60;), &#x60;channels&#x60; configuration is ignored and it will be recorded as mono (single channel).
   * @return recordTrack
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "outbound", value = "The audio track to be recorded. Can be either `both`, `inbound` or `outbound`. If only single track is specified (`inbound`, `outbound`), `channels` configuration is ignored and it will be recorded as mono (single channel).")
  @JsonProperty(JSON_PROPERTY_RECORD_TRACK)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public RecordTrackEnum getRecordTrack() {
    return recordTrack;
  }


  @JsonProperty(JSON_PROPERTY_RECORD_TRACK)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRecordTrack(RecordTrackEnum recordTrack) {
    this.recordTrack = recordTrack;
  }


  public CallRequest recordTrim(RecordTrimEnum recordTrim) {
    this.recordTrim = recordTrim;
    return this;
  }

   /**
   * When set to &#x60;trim-silence&#x60;, silence will be removed from the beginning and end of the recording.
   * @return recordTrim
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "trim-silence", value = "When set to `trim-silence`, silence will be removed from the beginning and end of the recording.")
  @JsonProperty(JSON_PROPERTY_RECORD_TRIM)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public RecordTrimEnum getRecordTrim() {
    return recordTrim;
  }


  @JsonProperty(JSON_PROPERTY_RECORD_TRIM)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRecordTrim(RecordTrimEnum recordTrim) {
    this.recordTrim = recordTrim;
  }


  public CallRequest recordCustomFileName(String recordCustomFileName) {
    this.recordCustomFileName = recordCustomFileName;
    return this;
  }

   /**
   * The custom recording file name to be used instead of the default &#x60;call_leg_id&#x60;. Telnyx will still add a Unix timestamp suffix.
   * @return recordCustomFileName
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "my_recording_file_name", value = "The custom recording file name to be used instead of the default `call_leg_id`. Telnyx will still add a Unix timestamp suffix.")
  @JsonProperty(JSON_PROPERTY_RECORD_CUSTOM_FILE_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getRecordCustomFileName() {
    return recordCustomFileName;
  }


  @JsonProperty(JSON_PROPERTY_RECORD_CUSTOM_FILE_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRecordCustomFileName(String recordCustomFileName) {
    this.recordCustomFileName = recordCustomFileName;
  }


  public CallRequest superviseCallControlId(String superviseCallControlId) {
    this.superviseCallControlId = superviseCallControlId;
    return this;
  }

   /**
   * The call leg which will be supervised by the new call.
   * @return superviseCallControlId
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg", value = "The call leg which will be supervised by the new call.")
  @JsonProperty(JSON_PROPERTY_SUPERVISE_CALL_CONTROL_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getSuperviseCallControlId() {
    return superviseCallControlId;
  }


  @JsonProperty(JSON_PROPERTY_SUPERVISE_CALL_CONTROL_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSuperviseCallControlId(String superviseCallControlId) {
    this.superviseCallControlId = superviseCallControlId;
  }


  public CallRequest supervisorRole(SupervisorRoleEnum supervisorRole) {
    this.supervisorRole = supervisorRole;
    return this;
  }

   /**
   * The role of the supervisor call. &#39;barge&#39; means that supervisor call hears and is being heard by both ends of the call (caller &amp; callee). &#39;whisper&#39; means that only supervised_call_control_id hears supervisor but supervisor can hear everything. &#39;monitor&#39; means that nobody can hear supervisor call, but supervisor can hear everything on the call.
   * @return supervisorRole
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "The role of the supervisor call. 'barge' means that supervisor call hears and is being heard by both ends of the call (caller & callee). 'whisper' means that only supervised_call_control_id hears supervisor but supervisor can hear everything. 'monitor' means that nobody can hear supervisor call, but supervisor can hear everything on the call.")
  @JsonProperty(JSON_PROPERTY_SUPERVISOR_ROLE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public SupervisorRoleEnum getSupervisorRole() {
    return supervisorRole;
  }


  @JsonProperty(JSON_PROPERTY_SUPERVISOR_ROLE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSupervisorRole(SupervisorRoleEnum supervisorRole) {
    this.supervisorRole = supervisorRole;
  }


  public CallRequest enableDialogflow(Boolean enableDialogflow) {
    this.enableDialogflow = enableDialogflow;
    return this;
  }

   /**
   * Enables Dialogflow for the current call. The default value is false.
   * @return enableDialogflow
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "true", value = "Enables Dialogflow for the current call. The default value is false.")
  @JsonProperty(JSON_PROPERTY_ENABLE_DIALOGFLOW)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getEnableDialogflow() {
    return enableDialogflow;
  }


  @JsonProperty(JSON_PROPERTY_ENABLE_DIALOGFLOW)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setEnableDialogflow(Boolean enableDialogflow) {
    this.enableDialogflow = enableDialogflow;
  }


  public CallRequest dialogflowConfig(DialogflowConfig dialogflowConfig) {
    this.dialogflowConfig = dialogflowConfig;
    return this;
  }

   /**
   * Get dialogflowConfig
   * @return dialogflowConfig
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_DIALOGFLOW_CONFIG)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public DialogflowConfig getDialogflowConfig() {
    return dialogflowConfig;
  }


  @JsonProperty(JSON_PROPERTY_DIALOGFLOW_CONFIG)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDialogflowConfig(DialogflowConfig dialogflowConfig) {
    this.dialogflowConfig = dialogflowConfig;
  }


  public CallRequest transcription(Boolean transcription) {
    this.transcription = transcription;
    return this;
  }

   /**
   * Enable transcription upon call answer. The default value is false.
   * @return transcription
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "true", value = "Enable transcription upon call answer. The default value is false.")
  @JsonProperty(JSON_PROPERTY_TRANSCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getTranscription() {
    return transcription;
  }


  @JsonProperty(JSON_PROPERTY_TRANSCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTranscription(Boolean transcription) {
    this.transcription = transcription;
  }


  public CallRequest transcriptionConfig(TranscriptionStartRequest transcriptionConfig) {
    this.transcriptionConfig = transcriptionConfig;
    return this;
  }

   /**
   * Get transcriptionConfig
   * @return transcriptionConfig
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_TRANSCRIPTION_CONFIG)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public TranscriptionStartRequest getTranscriptionConfig() {
    return transcriptionConfig;
  }


  @JsonProperty(JSON_PROPERTY_TRANSCRIPTION_CONFIG)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTranscriptionConfig(TranscriptionStartRequest transcriptionConfig) {
    this.transcriptionConfig = transcriptionConfig;
  }


  /**
   * Return true if this CallRequest object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CallRequest callRequest = (CallRequest) o;
    return Objects.equals(this.to, callRequest.to) &&
        Objects.equals(this.from, callRequest.from) &&
        Objects.equals(this.fromDisplayName, callRequest.fromDisplayName) &&
        Objects.equals(this.connectionId, callRequest.connectionId) &&
        Objects.equals(this.audioUrl, callRequest.audioUrl) &&
        Objects.equals(this.mediaName, callRequest.mediaName) &&
        Objects.equals(this.preferredCodecs, callRequest.preferredCodecs) &&
        Objects.equals(this.timeoutSecs, callRequest.timeoutSecs) &&
        Objects.equals(this.timeLimitSecs, callRequest.timeLimitSecs) &&
        Objects.equals(this.answeringMachineDetection, callRequest.answeringMachineDetection) &&
        Objects.equals(this.answeringMachineDetectionConfig, callRequest.answeringMachineDetectionConfig) &&
        Objects.equals(this.conferenceConfig, callRequest.conferenceConfig) &&
        Objects.equals(this.customHeaders, callRequest.customHeaders) &&
        Objects.equals(this.billingGroupId, callRequest.billingGroupId) &&
        Objects.equals(this.clientState, callRequest.clientState) &&
        Objects.equals(this.commandId, callRequest.commandId) &&
        Objects.equals(this.linkTo, callRequest.linkTo) &&
        Objects.equals(this.mediaEncryption, callRequest.mediaEncryption) &&
        Objects.equals(this.sipAuthUsername, callRequest.sipAuthUsername) &&
        Objects.equals(this.sipAuthPassword, callRequest.sipAuthPassword) &&
        Objects.equals(this.sipHeaders, callRequest.sipHeaders) &&
        Objects.equals(this.sipTransportProtocol, callRequest.sipTransportProtocol) &&
        Objects.equals(this.soundModifications, callRequest.soundModifications) &&
        Objects.equals(this.streamUrl, callRequest.streamUrl) &&
        Objects.equals(this.streamTrack, callRequest.streamTrack) &&
        Objects.equals(this.streamBidirectionalMode, callRequest.streamBidirectionalMode) &&
        Objects.equals(this.streamBidirectionalCodec, callRequest.streamBidirectionalCodec) &&
        Objects.equals(this.streamBidirectionalTargetLegs, callRequest.streamBidirectionalTargetLegs) &&
        Objects.equals(this.streamBidirectionalSamplingRate, callRequest.streamBidirectionalSamplingRate) &&
        Objects.equals(this.sendSilenceWhenIdle, callRequest.sendSilenceWhenIdle) &&
        Objects.equals(this.webhookUrl, callRequest.webhookUrl) &&
        Objects.equals(this.webhookUrlMethod, callRequest.webhookUrlMethod) &&
        Objects.equals(this.record, callRequest.record) &&
        Objects.equals(this.recordChannels, callRequest.recordChannels) &&
        Objects.equals(this.recordFormat, callRequest.recordFormat) &&
        Objects.equals(this.recordMaxLength, callRequest.recordMaxLength) &&
        Objects.equals(this.recordTimeoutSecs, callRequest.recordTimeoutSecs) &&
        Objects.equals(this.recordTrack, callRequest.recordTrack) &&
        Objects.equals(this.recordTrim, callRequest.recordTrim) &&
        Objects.equals(this.recordCustomFileName, callRequest.recordCustomFileName) &&
        Objects.equals(this.superviseCallControlId, callRequest.superviseCallControlId) &&
        Objects.equals(this.supervisorRole, callRequest.supervisorRole) &&
        Objects.equals(this.enableDialogflow, callRequest.enableDialogflow) &&
        Objects.equals(this.dialogflowConfig, callRequest.dialogflowConfig) &&
        Objects.equals(this.transcription, callRequest.transcription) &&
        Objects.equals(this.transcriptionConfig, callRequest.transcriptionConfig);
  }

  @Override
  public int hashCode() {
    return Objects.hash(to, from, fromDisplayName, connectionId, audioUrl, mediaName, preferredCodecs, timeoutSecs, timeLimitSecs, answeringMachineDetection, answeringMachineDetectionConfig, conferenceConfig, customHeaders, billingGroupId, clientState, commandId, linkTo, mediaEncryption, sipAuthUsername, sipAuthPassword, sipHeaders, sipTransportProtocol, soundModifications, streamUrl, streamTrack, streamBidirectionalMode, streamBidirectionalCodec, streamBidirectionalTargetLegs, streamBidirectionalSamplingRate, sendSilenceWhenIdle, webhookUrl, webhookUrlMethod, record, recordChannels, recordFormat, recordMaxLength, recordTimeoutSecs, recordTrack, recordTrim, recordCustomFileName, superviseCallControlId, supervisorRole, enableDialogflow, dialogflowConfig, transcription, transcriptionConfig);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CallRequest {\n");
    sb.append("    to: ").append(toIndentedString(to)).append("\n");
    sb.append("    from: ").append(toIndentedString(from)).append("\n");
    sb.append("    fromDisplayName: ").append(toIndentedString(fromDisplayName)).append("\n");
    sb.append("    connectionId: ").append(toIndentedString(connectionId)).append("\n");
    sb.append("    audioUrl: ").append(toIndentedString(audioUrl)).append("\n");
    sb.append("    mediaName: ").append(toIndentedString(mediaName)).append("\n");
    sb.append("    preferredCodecs: ").append(toIndentedString(preferredCodecs)).append("\n");
    sb.append("    timeoutSecs: ").append(toIndentedString(timeoutSecs)).append("\n");
    sb.append("    timeLimitSecs: ").append(toIndentedString(timeLimitSecs)).append("\n");
    sb.append("    answeringMachineDetection: ").append(toIndentedString(answeringMachineDetection)).append("\n");
    sb.append("    answeringMachineDetectionConfig: ").append(toIndentedString(answeringMachineDetectionConfig)).append("\n");
    sb.append("    conferenceConfig: ").append(toIndentedString(conferenceConfig)).append("\n");
    sb.append("    customHeaders: ").append(toIndentedString(customHeaders)).append("\n");
    sb.append("    billingGroupId: ").append(toIndentedString(billingGroupId)).append("\n");
    sb.append("    clientState: ").append(toIndentedString(clientState)).append("\n");
    sb.append("    commandId: ").append(toIndentedString(commandId)).append("\n");
    sb.append("    linkTo: ").append(toIndentedString(linkTo)).append("\n");
    sb.append("    mediaEncryption: ").append(toIndentedString(mediaEncryption)).append("\n");
    sb.append("    sipAuthUsername: ").append(toIndentedString(sipAuthUsername)).append("\n");
    sb.append("    sipAuthPassword: ").append(toIndentedString(sipAuthPassword)).append("\n");
    sb.append("    sipHeaders: ").append(toIndentedString(sipHeaders)).append("\n");
    sb.append("    sipTransportProtocol: ").append(toIndentedString(sipTransportProtocol)).append("\n");
    sb.append("    soundModifications: ").append(toIndentedString(soundModifications)).append("\n");
    sb.append("    streamUrl: ").append(toIndentedString(streamUrl)).append("\n");
    sb.append("    streamTrack: ").append(toIndentedString(streamTrack)).append("\n");
    sb.append("    streamBidirectionalMode: ").append(toIndentedString(streamBidirectionalMode)).append("\n");
    sb.append("    streamBidirectionalCodec: ").append(toIndentedString(streamBidirectionalCodec)).append("\n");
    sb.append("    streamBidirectionalTargetLegs: ").append(toIndentedString(streamBidirectionalTargetLegs)).append("\n");
    sb.append("    streamBidirectionalSamplingRate: ").append(toIndentedString(streamBidirectionalSamplingRate)).append("\n");
    sb.append("    sendSilenceWhenIdle: ").append(toIndentedString(sendSilenceWhenIdle)).append("\n");
    sb.append("    webhookUrl: ").append(toIndentedString(webhookUrl)).append("\n");
    sb.append("    webhookUrlMethod: ").append(toIndentedString(webhookUrlMethod)).append("\n");
    sb.append("    record: ").append(toIndentedString(record)).append("\n");
    sb.append("    recordChannels: ").append(toIndentedString(recordChannels)).append("\n");
    sb.append("    recordFormat: ").append(toIndentedString(recordFormat)).append("\n");
    sb.append("    recordMaxLength: ").append(toIndentedString(recordMaxLength)).append("\n");
    sb.append("    recordTimeoutSecs: ").append(toIndentedString(recordTimeoutSecs)).append("\n");
    sb.append("    recordTrack: ").append(toIndentedString(recordTrack)).append("\n");
    sb.append("    recordTrim: ").append(toIndentedString(recordTrim)).append("\n");
    sb.append("    recordCustomFileName: ").append(toIndentedString(recordCustomFileName)).append("\n");
    sb.append("    superviseCallControlId: ").append(toIndentedString(superviseCallControlId)).append("\n");
    sb.append("    supervisorRole: ").append(toIndentedString(supervisorRole)).append("\n");
    sb.append("    enableDialogflow: ").append(toIndentedString(enableDialogflow)).append("\n");
    sb.append("    dialogflowConfig: ").append(toIndentedString(dialogflowConfig)).append("\n");
    sb.append("    transcription: ").append(toIndentedString(transcription)).append("\n");
    sb.append("    transcriptionConfig: ").append(toIndentedString(transcriptionConfig)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

